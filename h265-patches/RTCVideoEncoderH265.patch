--- /dev/null
+++ src/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
@@ -0,0 +1,481 @@
+/*
+ *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#import "RTCVideoEncoderH265.h"
+
+#import <VideoToolbox/VideoToolbox.h>
+#include <vector>
+
+#if defined(WEBRTC_IOS)
+#import "helpers/UIDevice+RTCDevice.h"
+#endif
+#import "RTCCodecSpecificInfoH265.h"
+#import "api/peerconnection/RTCVideoCodecInfo+Private.h"
+#import "base/RTCCodecSpecificInfo.h"
+#import "base/RTCI420Buffer.h"
+#import "base/RTCVideoEncoder.h"
+#import "base/RTCVideoFrame.h"
+#import "base/RTCVideoFrameBuffer.h"
+#import "components/video_frame_buffer/RTCCVPixelBuffer.h"
+#import "helpers.h"
+
+#include "api/video/video_timing.h"
+#ifdef RTC_ENABLE_H265
+#include "common_video/h265/h265_bitstream_parser.h"
+#endif
+#include "common_video/include/bitrate_adjuster.h"
+#include "modules/video_coding/include/video_error_codes.h"
+#include "rtc_base/buffer.h"
+#include "rtc_base/logging.h"
+#include "rtc_base/time_utils.h"
+#include "sdk/objc/components/video_codec/nalu_rewriter.h"
+#include "third_party/libyuv/include/libyuv/convert_from.h"
+
+extern NSString *const kRTCVideoCodecH265Name;
+
+@interface RTC_OBJC_TYPE (RTCVideoEncoderH265)
+()
+
+- (void)frameWasEncoded:(OSStatus)status
+                  flags:(VTEncodeInfoFlags)infoFlags
+           sampleBuffer:(CMSampleBufferRef)sampleBuffer
+      codecSpecificInfo:(id<RTC_OBJC_TYPE(RTCCodecSpecificInfo)>)codecSpecificInfo
+                  width:(int32_t)width
+                 height:(int32_t)height
+           renderTimeMs:(int64_t)renderTimeMs
+              timestamp:(uint32_t)timestamp
+               rotation:(RTCVideoRotation)rotation;
+
+@end
+
+namespace {  // anonymous namespace
+
+// H.265 QP thresholds - similar to H.264 but adjusted for H.265 characteristics
+const int kLowH265QpThreshold = 24;
+const int kHighH265QpThreshold = 37;
+
+const OSType kNV12PixelFormat = kCVPixelFormatType_420YpCbCr8BiPlanarFullRange;
+// const float kLimitToAverageBitRateFactor = 1.5f;  // Currently unused
+
+// Struct that we pass to the encoder per frame to encode
+struct RTCH265FrameEncodeParams {
+  RTCH265FrameEncodeParams(RTC_OBJC_TYPE(RTCVideoEncoderH265) * e,
+                           RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) * csi,
+                           int32_t w,
+                           int32_t h,
+                           int64_t rtms,
+                           uint32_t ts,
+                           RTCVideoRotation r)
+      : encoder(e),
+        width(w),
+        height(h),
+        render_time_ms(rtms),
+        timestamp(ts),
+        rotation(r) {
+    if (csi) {
+      codecSpecificInfo = csi;
+    } else {
+      codecSpecificInfo = [[RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) alloc] init];
+    }
+  }
+
+  RTC_OBJC_TYPE(RTCVideoEncoderH265) * encoder;
+  RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) * codecSpecificInfo;
+  int32_t width;
+  int32_t height;
+  int64_t render_time_ms;
+  uint32_t timestamp;
+  RTCVideoRotation rotation;
+};
+
+// Copy I420 frame to NV12 pixel buffer (same as H.264)
+bool CopyVideoFrameToNV12PixelBuffer(
+    id<RTC_OBJC_TYPE(RTCI420Buffer)> frameBuffer,
+    CVPixelBufferRef pixelBuffer) {
+  RTC_DCHECK(pixelBuffer);
+  RTC_DCHECK_EQ(CVPixelBufferGetPixelFormatType(pixelBuffer), kNV12PixelFormat);
+  RTC_DCHECK_EQ(CVPixelBufferGetHeightOfPlane(pixelBuffer, 0), frameBuffer.height);
+  RTC_DCHECK_EQ(CVPixelBufferGetWidthOfPlane(pixelBuffer, 0), frameBuffer.width);
+
+  CVReturn cvRet = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
+  if (cvRet != kCVReturnSuccess) {
+    RTC_LOG(LS_ERROR) << "Failed to lock base address: " << cvRet;
+    return false;
+  }
+  
+  uint8_t *dstY = reinterpret_cast<uint8_t *>(
+      CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0));
+  int dstStrideY = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
+  uint8_t *dstUV = reinterpret_cast<uint8_t *>(
+      CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1));
+  int dstStrideUV = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1);
+  
+  // Convert I420 to NV12
+  int ret = libyuv::I420ToNV12(frameBuffer.dataY,
+                               frameBuffer.strideY,
+                               frameBuffer.dataU,
+                               frameBuffer.strideU,
+                               frameBuffer.dataV,
+                               frameBuffer.strideV,
+                               dstY,
+                               dstStrideY,
+                               dstUV,
+                               dstStrideUV,
+                               frameBuffer.width,
+                               frameBuffer.height);
+  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
+  if (ret) {
+    RTC_LOG(LS_ERROR) << "Error converting I420 VideoFrame to NV12: " << ret;
+    return false;
+  }
+  return true;
+}
+
+CVPixelBufferRef CreatePixelBuffer(VTCompressionSessionRef compression_session) {
+  if (!compression_session) {
+    RTC_LOG(LS_ERROR) << "Failed to get compression session.";
+    return nullptr;
+  }
+  
+  CVPixelBufferPoolRef pixel_buffer_pool =
+      VTCompressionSessionGetPixelBufferPool(compression_session);
+  if (!pixel_buffer_pool) {
+    RTC_LOG(LS_ERROR) << "Failed to get pixel buffer pool.";
+    return nullptr;
+  }
+  
+  CVPixelBufferRef pixel_buffer;
+  CVReturn ret = CVPixelBufferPoolCreatePixelBuffer(
+      nullptr, pixel_buffer_pool, &pixel_buffer);
+  if (ret != kCVReturnSuccess) {
+    RTC_LOG(LS_ERROR) << "Failed to create pixel buffer: " << ret;
+    return nullptr;
+  }
+  return pixel_buffer;
+}
+
+// H.265 compression callback
+void h265CompressionOutputCallback(void *encoder,
+                                   void *params,
+                                   OSStatus status,
+                                   VTEncodeInfoFlags infoFlags,
+                                   CMSampleBufferRef sampleBuffer) {
+  if (!params) {
+    return;
+  }
+  
+  std::unique_ptr<RTCH265FrameEncodeParams> encodeParams(
+      reinterpret_cast<RTCH265FrameEncodeParams *>(params));
+  [encodeParams->encoder frameWasEncoded:status
+                                   flags:infoFlags
+                            sampleBuffer:sampleBuffer
+                       codecSpecificInfo:encodeParams->codecSpecificInfo
+                                   width:encodeParams->width
+                                  height:encodeParams->height
+                            renderTimeMs:encodeParams->render_time_ms
+                               timestamp:encodeParams->timestamp
+                                rotation:encodeParams->rotation];
+}
+
+}  // namespace
+
+@implementation RTC_OBJC_TYPE (RTCVideoEncoderH265) {
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *_codecInfo;
+  std::unique_ptr<webrtc::BitrateAdjuster> _bitrateAdjuster;
+  uint32_t _targetBitrateBps;
+  uint32_t _encoderBitrateBps;
+  uint32_t _encoderFramerate;
+  VTCompressionSessionRef _compressionSession;
+  RTCVideoEncoderCallback _callback;
+  int32_t _width;
+  int32_t _height;
+}
+
+@synthesize supportsNativeHandle = _supportsNativeHandle;
+@synthesize resolutionAlignment = _resolutionAlignment;
+@synthesize applyAlignmentToAllSimulcastLayers = _applyAlignmentToAllSimulcastLayers;
+
+- (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo {
+  if ((self = [super init])) {
+    _codecInfo = codecInfo;
+    _bitrateAdjuster.reset(new webrtc::BitrateAdjuster(.5, .95));
+    _compressionSession = nullptr;
+    _supportsNativeHandle = YES;
+    _resolutionAlignment = 1;
+    _applyAlignmentToAllSimulcastLayers = NO;
+  }
+  return self;
+}
+
+- (void)dealloc {
+  [self destroyCompressionSession];
+}
+
+- (NSInteger)startEncodeWithSettings:(RTC_OBJC_TYPE(RTCVideoEncoderSettings) *)settings
+                numberOfCores:(int)numberOfCores {
+  RTC_DCHECK(settings);
+  RTC_DCHECK([settings.name isEqualToString:kRTCVideoCodecH265Name]);
+
+  _width = settings.width;
+  _height = settings.height;
+  _targetBitrateBps = settings.startBitrate;
+  _bitrateAdjuster->SetTargetBitrateBps(_targetBitrateBps);
+  
+  return [self resetCompressionSession];
+}
+
+- (NSInteger)resetCompressionSession {
+  [self destroyCompressionSession];
+
+  // Create compression session
+  OSStatus status = VTCompressionSessionCreate(
+      nullptr,  // allocator
+      _width,
+      _height,
+      kCMVideoCodecType_HEVC,  // H.265
+      nullptr,  // encoder specification
+      nullptr,  // source image buffer attributes
+      nullptr,  // compressed data allocator
+      h265CompressionOutputCallback,
+      (__bridge void *)self,  // callback reference
+      &_compressionSession);
+
+  if (status != noErr) {
+    RTC_LOG(LS_ERROR) << "Failed to create H.265 compression session: " << status;
+    return WEBRTC_VIDEO_CODEC_ERROR;
+  }
+
+  [self configureCompressionSession];
+  return WEBRTC_VIDEO_CODEC_OK;
+}
+
+- (void)configureCompressionSession {
+  RTC_DCHECK(_compressionSession);
+
+  // Configure for realtime encoding
+  VTSessionSetProperty(_compressionSession,
+                      kVTCompressionPropertyKey_RealTime,
+                      kCFBooleanTrue);
+
+  // Set profile and level
+  VTSessionSetProperty(_compressionSession,
+                      kVTCompressionPropertyKey_ProfileLevel,
+                      kVTProfileLevel_HEVC_Main_AutoLevel);
+
+  // Configure bitrate
+  [self setBitrateBps:_targetBitrateBps];
+  
+  // Configure max keyframe interval  
+  VTSessionSetProperty(_compressionSession,
+                      kVTCompressionPropertyKey_MaxKeyFrameInterval,
+                      (__bridge CFTypeRef)@(240));
+}
+
+- (void)setBitrateBps:(uint32_t)bitrateBps {
+  if (_compressionSession) {
+    VTSessionSetProperty(_compressionSession,
+                        kVTCompressionPropertyKey_AverageBitRate,
+                        (__bridge CFTypeRef)@(bitrateBps));
+  }
+  _encoderBitrateBps = bitrateBps;
+}
+
+- (NSInteger)encode:(RTC_OBJC_TYPE(RTCVideoFrame) *)frame
+    codecSpecificInfo:(nullable id<RTC_OBJC_TYPE(RTCCodecSpecificInfo)>)info
+           frameTypes:(NSArray<NSNumber *> *)frameTypes {
+  RTC_DCHECK_EQ(frame.width, _width);
+  RTC_DCHECK_EQ(frame.height, _height);
+
+  if (!_compressionSession) {
+    return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
+  }
+
+  CVPixelBufferRef pixelBuffer = nullptr;
+  if ([frame.buffer isKindOfClass:[RTC_OBJC_TYPE(RTCCVPixelBuffer) class]]) {
+    // Use existing CVPixelBuffer
+    RTC_OBJC_TYPE(RTCCVPixelBuffer) *rtcPixelBuffer =
+        (RTC_OBJC_TYPE(RTCCVPixelBuffer) *)frame.buffer;
+    pixelBuffer = rtcPixelBuffer.pixelBuffer;
+    CVBufferRetain(pixelBuffer);
+  } else {
+    // Convert I420 to CVPixelBuffer
+    pixelBuffer = CreatePixelBuffer(_compressionSession);
+    if (!pixelBuffer) {
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+    
+    id<RTC_OBJC_TYPE(RTCI420Buffer)> frameBuffer = [frame.buffer toI420];
+    if (!CopyVideoFrameToNV12PixelBuffer(frameBuffer, pixelBuffer)) {
+      CVBufferRelease(pixelBuffer);
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+  }
+
+  // Check if keyframe is requested
+  bool isKeyframeRequired = false;
+  for (NSNumber *frameType in frameTypes) {
+    if ((RTCFrameType)frameType.intValue == RTCFrameTypeVideoFrameKey) {
+      isKeyframeRequired = true;
+      break;
+    }
+  }
+
+  CFDictionaryRef frameProperties = nullptr;
+  if (isKeyframeRequired) {
+    CFTypeRef keys[] = {kVTEncodeFrameOptionKey_ForceKeyFrame};
+    CFTypeRef values[] = {kCFBooleanTrue};
+    frameProperties = CFDictionaryCreate(nullptr, keys, values, 1,
+                                        &kCFTypeDictionaryKeyCallBacks,
+                                        &kCFTypeDictionaryValueCallBacks);
+  }
+
+  auto encodeParams = std::make_unique<RTCH265FrameEncodeParams>(
+      self,
+      (RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) *)info,
+      frame.width,
+      frame.height,
+      frame.timeStampNs / webrtc::kNumNanosecsPerMillisec,
+      frame.timeStamp,
+      frame.rotation);
+
+  OSStatus status = VTCompressionSessionEncodeFrame(
+      _compressionSession,
+      pixelBuffer,
+      CMTimeMake(frame.timeStamp, 90000),  // 90kHz timestamp
+      kCMTimeInvalid,  // duration
+      frameProperties,
+      encodeParams.release(),  // callback will delete
+      nullptr);
+
+  if (frameProperties) {
+    CFRelease(frameProperties);
+  }
+  CVBufferRelease(pixelBuffer);
+
+  if (status != noErr) {
+    RTC_LOG(LS_ERROR) << "Failed to encode H.265 frame: " << status;
+    return WEBRTC_VIDEO_CODEC_ERROR;
+  }
+
+  return WEBRTC_VIDEO_CODEC_OK;
+}
+
+- (NSString *)implementationName {
+  return @"VideoToolbox H.265";
+}
+
+- (void)setCallback:(RTCVideoEncoderCallback)callback {
+  _callback = callback;
+}
+
+- (int)setBitrate:(uint32_t)bitrateKbit framerate:(uint32_t)framerate {
+  uint32_t bitrateBps = bitrateKbit * 1000;
+  _targetBitrateBps = bitrateBps;
+  _bitrateAdjuster->SetTargetBitrateBps(bitrateBps);
+  [self setBitrateBps:bitrateBps];
+  _encoderFramerate = framerate;
+  return WEBRTC_VIDEO_CODEC_OK;
+}
+
+- (NSInteger)releaseEncoder {
+  [self destroyCompressionSession];
+  return WEBRTC_VIDEO_CODEC_OK;
+}
+
+- (RTCVideoEncoderQpThresholds *)scalingSettings {
+  return [[RTCVideoEncoderQpThresholds alloc]
+      initWithThresholdsLow:kLowH265QpThreshold
+                       high:kHighH265QpThreshold];
+}
+
+#pragma mark - Private
+
+- (void)destroyCompressionSession {
+  if (_compressionSession) {
+    VTCompressionSessionInvalidate(_compressionSession);
+    CFRelease(_compressionSession);
+    _compressionSession = nullptr;
+  }
+}
+
+- (void)frameWasEncoded:(OSStatus)status
+                  flags:(VTEncodeInfoFlags)infoFlags
+           sampleBuffer:(CMSampleBufferRef)sampleBuffer
+      codecSpecificInfo:(id<RTC_OBJC_TYPE(RTCCodecSpecificInfo)>)codecSpecificInfo
+                  width:(int32_t)width
+                 height:(int32_t)height
+           renderTimeMs:(int64_t)renderTimeMs
+              timestamp:(uint32_t)timestamp
+               rotation:(RTCVideoRotation)rotation {
+  if (status != noErr) {
+    RTC_LOG(LS_ERROR) << "H.265 encode failed: " << status;
+    return;
+  }
+
+  if (!sampleBuffer) {
+    return;
+  }
+
+  // Get encoded data
+  CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);
+  if (!blockBuffer) {
+    RTC_LOG(LS_ERROR) << "Failed to get block buffer";
+    return;
+  }
+
+  size_t totalBytes;
+  char *dataPointer;
+  OSStatus bufferStatus = CMBlockBufferGetDataPointer(
+      blockBuffer, 0, nullptr, &totalBytes, &dataPointer);
+  if (bufferStatus != noErr) {
+    RTC_LOG(LS_ERROR) << "Failed to get data pointer: " << bufferStatus;
+    return;
+  }
+
+  // Create RTC encoded image
+  RTC_OBJC_TYPE(RTCEncodedImage) *encodedImage =
+      [[RTC_OBJC_TYPE(RTCEncodedImage) alloc] init];
+  encodedImage.buffer = [NSData dataWithBytes:dataPointer length:totalBytes];
+  encodedImage.encodedWidth = width;
+  encodedImage.encodedHeight = height;
+  encodedImage.timeStamp = timestamp;
+  encodedImage.captureTimeMs = renderTimeMs;
+  encodedImage.rotation = rotation;
+  encodedImage.contentType = RTCVideoContentTypeUnspecified;
+
+  // Determine frame type
+  bool isKeyframe = false;
+  CFArrayRef attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, 0);
+  if (attachments && CFArrayGetCount(attachments)) {
+    CFDictionaryRef attachment = (CFDictionaryRef)CFArrayGetValueAtIndex(attachments, 0);
+    isKeyframe = !CFDictionaryContainsKey(attachment, kCMSampleAttachmentKey_NotSync);
+  }
+  
+  encodedImage.frameType = isKeyframe ? RTCFrameTypeVideoFrameKey 
+                                      : RTCFrameTypeVideoFrameDelta;
+
+  // Parse QP if H.265 parser is available
+#ifdef RTC_ENABLE_H265
+  // H.265 QP parsing - simplified for now
+  // TODO: Implement proper H.265 bitstream parsing when available
+#endif
+
+  // Apply bitrate adjustment
+  _bitrateAdjuster->Update(totalBytes);
+  uint32_t adjustedBitrate = _bitrateAdjuster->GetAdjustedBitrateBps();
+  if (adjustedBitrate != _encoderBitrateBps) {
+    [self setBitrateBps:adjustedBitrate];
+  }
+
+  // Call callback
+  _callback(encodedImage, codecSpecificInfo);
+}
+
+@end
