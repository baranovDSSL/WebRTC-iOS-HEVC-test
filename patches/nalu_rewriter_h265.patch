--- src/sdk/objc/components/video_codec/nalu_rewriter.cc
+++ src/sdk/objc/components/video_codec/nalu_rewriter.cc
@@ -20,6 +20,7 @@
 
 #include "api/array_view.h"
 #include "common_video/h264/h264_common.h"
+#include "common_video/h265/h265_common.h"
 #include "rtc_base/buffer.h"
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
@@ -159,6 +160,107 @@
     }
   } else {
     // No SPS NALU - start reading from the first NALU in the buffer
+    reader.SeekToStart();
+  }
+
+  // Allocate memory as a block buffer.
+  CMBlockBufferRef block_buffer = nullptr;
+  CFAllocatorRef block_allocator = CMMemoryPoolGetAllocator(memory_pool);
+  OSStatus status = CMBlockBufferCreateWithMemoryBlock(
+      kCFAllocatorDefault, nullptr, reader.BytesRemaining(), block_allocator,
+      nullptr, 0, reader.BytesRemaining(), kCMBlockBufferAssureMemoryNowFlag,
+      &block_buffer);
+  if (status != kCMBlockBufferNoErr) {
+    RTC_LOG(LS_ERROR) << "Failed to create block buffer.";
+    return false;
+  }
+
+  // Make sure block buffer is contiguous.
+  CMBlockBufferRef contiguous_buffer = nullptr;
+  if (!CMBlockBufferIsRangeContiguous(block_buffer, 0, 0)) {
+    status = CMBlockBufferCreateContiguous(kCFAllocatorDefault, block_buffer,
+                                           block_allocator, nullptr, 0, 0, 0,
+                                           &contiguous_buffer);
+    if (status != noErr) {
+      RTC_LOG(LS_ERROR) << "Failed to flatten non-contiguous block buffer: "
+                        << status;
+      CFRelease(block_buffer);
+      return false;
+    }
+  } else {
+    contiguous_buffer = block_buffer;
+    block_buffer = nullptr;
+  }
+
+  // Get a raw pointer into allocated memory.
+  size_t block_buffer_size = 0;
+  char* data_ptr = nullptr;
+  status = CMBlockBufferGetDataPointer(contiguous_buffer, 0, nullptr,
+                                       &block_buffer_size, &data_ptr);
+  if (status != kCMBlockBufferNoErr) {
+    RTC_LOG(LS_ERROR) << "Failed to get block buffer data pointer.";
+    CFRelease(contiguous_buffer);
+    return false;
+  }
+  RTC_DCHECK(block_buffer_size == reader.BytesRemaining());
+
+  // Write Avcc NALUs into block buffer memory.
+  AvccBufferWriter writer(
+      MakeArrayView(reinterpret_cast<uint8_t*>(data_ptr), block_buffer_size));
+  while (reader.BytesRemaining() > 0) {
+    ArrayView<const uint8_t> nalu_data;
+    if (reader.ReadNalu(nalu_data)) {
+      writer.WriteNalu(nalu_data);
+    }
+  }
+
+  // Create sample buffer.
+  status = CMSampleBufferCreate(kCFAllocatorDefault, contiguous_buffer, true,
+                                nullptr, nullptr, video_format, 1, 0, nullptr,
+                                0, nullptr, out_sample_buffer);
+  if (status != noErr) {
+    RTC_LOG(LS_ERROR) << "Failed to create sample buffer.";
+    CFRelease(contiguous_buffer);
+    return false;
+  }
+  CFRelease(contiguous_buffer);
+  return true;
+}
+
+bool H265AnnexBBufferToCMSampleBuffer(ArrayView<const uint8_t> annexb_buffer,
+                                      CMVideoFormatDescriptionRef video_format,
+                                      CMSampleBufferRef* out_sample_buffer,
+                                      CMMemoryPoolRef memory_pool) {
+  RTC_DCHECK(out_sample_buffer);
+  RTC_DCHECK(video_format);
+  *out_sample_buffer = nullptr;
+
+  AnnexBBufferReader reader(annexb_buffer);
+  
+  // For H.265: Check for VPS first, then SPS. Skip parameter sets if found.
+  if (reader.SeekToNextNaluOfType(static_cast<H264::NaluType>(H265::NaluType::kVps))) {
+    // Buffer contains VPS - skip VPS, SPS, and PPS
+    ArrayView<const uint8_t> data;
+    if (!reader.ReadNalu(data)) {
+      return false;
+    }
+    if (!reader.ReadNalu(data)) {
+      return false;
+    }
+    if (!reader.ReadNalu(data)) {
+      return false;
+    }
+  } else if (reader.SeekToNextNaluOfType(static_cast<H264::NaluType>(H265::NaluType::kSps))) {
+    // No VPS, but has SPS - skip SPS and PPS
+    ArrayView<const uint8_t> data;
+    if (!reader.ReadNalu(data)) {
+      return false;
+    }
+    if (!reader.ReadNalu(data)) {
+      return false;
+    }
+  } else {
+    // No parameter sets - start reading from the first NALU in the buffer
     reader.SeekToStart();
   }
 
@@ -323,4 +425,70 @@
   return buffer_.size();
 }
 
+CMVideoFormatDescriptionRef CreateVideoFormatDescriptionH265(
+    ArrayView<const uint8_t> annexb_buffer) {
+  
+  // First, let's see what NAL units are actually in this buffer
+  std::vector<H265::NaluIndex> nalu_indices = H265::FindNaluIndices(annexb_buffer);
+  
+  // Extract H.265 parameter sets from NAL units (based on our log analysis)
+  const uint8_t* param_set_ptrs[3] = {};
+  size_t param_set_sizes[3] = {};
+  int param_count = 0;
+  
+  // Use direct H.265 NAL unit extraction (not H.264 AnnexBBufferReader)
+  for (size_t i = 0; i < nalu_indices.size(); ++i) {
+    const H265::NaluIndex& nalu = nalu_indices[i];
+    if (nalu.payload_size >= 2) {
+      uint8_t nal_type = (annexb_buffer[nalu.payload_start_offset] >> 1) & 0x3F;
+      
+      if (nal_type == 32) {  // VPS
+        param_set_ptrs[param_count] = &annexb_buffer[nalu.payload_start_offset];
+        param_set_sizes[param_count] = nalu.payload_size;
+        param_count++;
+      }
+      else if (nal_type == 33) {  // SPS
+        param_set_ptrs[param_count] = &annexb_buffer[nalu.payload_start_offset];
+        param_set_sizes[param_count] = nalu.payload_size;
+        param_count++;
+      }
+      else if (nal_type == 34) {  // PPS
+        param_set_ptrs[param_count] = &annexb_buffer[nalu.payload_start_offset];
+        param_set_sizes[param_count] = nalu.payload_size;
+        param_count++;
+      }
+    }
+  }
+  
+  // Validate we have the required parameter sets
+  if (param_count == 0) {
+    return nullptr;
+  }
+  
+  // We need at least SPS and PPS for H.265
+  bool has_sps = false, has_pps = false;
+  for (int i = 0; i < param_count; i++) {
+    if (param_set_sizes[i] >= 2) {
+      uint8_t nal_type = (param_set_ptrs[i][0] >> 1) & 0x3F;
+      if (nal_type == 33) has_sps = true;
+      if (nal_type == 34) has_pps = true;
+    }
+  }
+  
+  if (!has_sps || !has_pps) {
+    return nullptr;
+  }
+
+
+  // Parse the parameter sets into a CMVideoFormatDescription
+  CMVideoFormatDescriptionRef description = nullptr;
+  OSStatus status = CMVideoFormatDescriptionCreateFromHEVCParameterSets(
+      kCFAllocatorDefault, param_count, param_set_ptrs, param_set_sizes, 4, nullptr, &description);
+  if (status != noErr) {
+    return nullptr;
+  }
+
+  return description;
+}
+
 }  // namespace webrtc
